# Проект "Разработка стратегии в стиле боя в игре "Герои Меча и Магии 3" против искусственного интеллекта"

### Что нужно делать

В проекте библиотеки игры `heroes_task_lib` определено четыре интерфейса, методы которых вам предстоит имплементировать в 
проекте heroes_task согласно документации. Это интерфейсы `GeneratePreset`, `SimulateBattle`, `SuitableForAttackUnitsFinder` и `UnitTargetPathFinder`.

Интерфейсы отвечают за реализацию следующего логического функционала внутри основного проекта игры:

* GeneratePreset содержит метод `Army generate(List unitList, int maxPoints);`, который отвечает за генерацию пресета армии противника.
* SimulateBattle содержит метод `void simulate(Army playerArmy, Army computerArmy) throws InterruptedException;` и отвечает за осуществление симуляции боя.
* SuitableForAttackUnitsFinder содержит метод `List getSuitableUnits(List> unitsByRow, boolean isLeftArmyTarget);` и отвечает за создание перечня подходящих для атаки юнитов.
* UnitTargetPathFinder содержит метод `List getTargetPath(Unit attackUnit, Unit targetUnit, List existingUnitList);` и отвечает за поиск кратчайшего пути между атакующим и атакуемым юнитом.
Вам дан проект `heroes_task` с уже подключенной библиотекой `heroes_task_lib` и созданными заготовками имплементации для каждого интерфейса.

### Описание реализации

#### GeneratePresetImpl
Класс генерации пресета

Содержит метод `Army generate(List unitList, int maxPoints)` для генерации пресета. 
Примерная сложность O(n*m), где n - число типов юнитов, а m - максимальное число юнитов в 
армии одного типа, так как максимально возможное количество юнитов на карте это 11 * `количество типов`,
по этому алгоритм такой:
 - выполняю 11 * `количество типов` итераций в цикле
 - постепенно добавляю юниты каждого типа, пока их не станет 11 или не кончатся ресурсы
 - это сделано чтобы типы юнитов распределились равномерно

На мой взгляд, сделать именно разнообразную армию довольно логичный шаг, так как нет требования к максимизации очков 
атаки или очков жизни.
Получается что сложность по сути константная - типов юнитов 4, а максимум в армию можно добавить 11 юнитов одного типа, 
то есть при генерации армии будет использовано максимум 44 итерации

#### SimulateBattleImpl
Класс симуляции битвы, содержит реализацию ходов игроков по очереди

Содержит метод `void simulate(Army playerArmy, Army computerArmy) throws InterruptedException` для симуляции битвы
Примерная сложность: O(n+m). (n - размер армии игрока, m - размер армии компьютера)
По сути реализованы ходы по очереди, боец каждый раз выбирается случайным образом
 - выполняем цикл, пока одна из армий не опустеет
 - делаем ход игрока, и удаляем вражеский юнит, если нужно
 - делаем ход компьютера, и удаляем вражеский юнит, если нужно

#### SuitableForAttackUnitsFinderImpl
Класс для поиска юнитов, подходящих для атаки

Содержит метод `List getSuitableUnits(List> unitsByRow, boolean isLeftArmyTarget)`, который определяет список юнитов, 
подходящих для атаки, для атакующего юнита одной из армий.
Цель метода — исключить ненужные попытки найти кратчайший путь между юнитами,
которые не могут атаковать друг друга.
Сложность: O(n*m) - (n - количество колонок, m - количество юнитов в колонке)
 - делаю обход колонок в цикле, в зависимости от того с какой стороны армия, это будет прямой или обратный обход
 - при обходе запоминаю юниты колонки в массив, при следующей итерации использую сохраненные данные,
   чтоб понять есть ли юнит перед текущим в этой же строке

Все очень просто: цикл идет от внешней шеренги юнитов и записывает положения юнитов в массив. Массив даже чистить не 
надо, так как если перед юнитом кто-то стоит, то атаковать его нельзя (там же всего три колонки, вариант того что юнит 
может бродить между шеренгами в поиске пути к врагу я думаю рассматривать не стоит)

#### UnitTargetPathFinderImpl
Класс поиска пути между юнитами

Содержит метод `List getTargetPath(Unit attackUnit, Unit targetUnit, List existingUnitList)`, который определяет 
кратчайший маршрут между атакующим и атакуемым юнитом и возвращает его в виде списка объектов
содержащих координаты каждой точки данного кратчайшего пути.
Сложность: O(n * m * log(n * m)). (n - ширина, m - высота поля)
 - использую цикл, количество итераций не может превышать количество клеток игрового поля (n * m)
 - для каждой клетки добавляется значение дистанции в приоритетную очередь, тут сложность получается ~ log(n * m)
