# Проект "Разработка стратегии в стиле боя в игре "Герои Меча и Магии 3" против искусственного интеллекта"

### Что нужно делать

В проекте библиотеки игры `heroes_task_lib` определено четыре интерфейса, методы которых вам предстоит имплементировать в
проекте heroes_task согласно документации. Это интерфейсы `GeneratePreset`, `SimulateBattle`, `SuitableForAttackUnitsFinder` и `UnitTargetPathFinder`.

Интерфейсы отвечают за реализацию следующего логического функционала внутри основного проекта игры:

* GeneratePreset содержит метод `Army generate(List unitList, int maxPoints);`, который отвечает за генерацию пресета армии противника.
* SimulateBattle содержит метод `void simulate(Army playerArmy, Army computerArmy) throws InterruptedException;` и отвечает за осуществление симуляции боя.
* SuitableForAttackUnitsFinder содержит метод `List getSuitableUnits(List> unitsByRow, boolean isLeftArmyTarget);` и отвечает за создание перечня подходящих для атаки юнитов.
* UnitTargetPathFinder содержит метод `List getTargetPath(Unit attackUnit, Unit targetUnit, List existingUnitList);` и отвечает за поиск кратчайшего пути между атакующим и атакуемым юнитом.
  Вам дан проект `heroes_task` с уже подключенной библиотекой `heroes_task_lib` и созданными заготовками имплементации для каждого интерфейса.

### Описание реализации

#### GeneratePresetImpl
Класс генерации пресета

Содержит метод `Army generate(List unitList, int maxPoints)` для генерации пресета.
Примерная сложность O(n*m), где n - число типов юнитов, а m - максимальное число юнитов одного типа,
так как максимально возможное количество юнитов на карте это 11 * `количество типов` максимум,
по этому алгоритм такой:
- выполняю сортировку типов юнитов, так чтобы сначала шли юниты с самой большой атакой и самым большим здоровьем. Сложность сортировки - log(n)
- выполняю основной цикл по количеству типов юнитов
- выполняю вложенный цикл для каждого типа юнитов, в котором содаются новые юниты. Количество итераций определяю
  исходя из оставшихся ресурсов, то есть юнитов в итоге должно добавиться или 11 или на сколько хватит ресурсов,
  в зависимости от того что меньше

Получается что сложность добавления по сути константная - типов юнитов 4, а максимум в армию можно добавить 11 юнитов каждого типа,
то есть при генерации армии будет использовано максимум 44 итерации + сортировка со сложностью log(n), но там всего 4 элемента.
Чтобы не искать итеративно свободные ячейки, делаю массив объектов, хранящих информацию свободных местах в линиях.
Ячейки заполняются от правой (3-я колонка) к левой (1-я колонка), таким образом самые сильные юниты должны быть
в основном в правой колонке, то есть ближе к юнитам противника, это потому что первыми создаются самые сильные юниты и они занимают первые места справа
При заполнении линии (3 юнита) - удаляю объект из коллекции.
Итого сложность поиска координат константная: создать массив - O(21), выбрать случайную линию - O(1), удалить заполненную линию - O(1)

#### SimulateBattleImpl
Класс симуляции битвы, содержит реализацию ходов игроков по очереди

Содержит метод `void simulate(Army playerArmy, Army computerArmy) throws InterruptedException` для симуляции битвы
Примерная сложность: O(n+m). (n - размер армии игрока, m - размер армии компьютера)
По сути реализованы ходы по очереди, боец каждый раз выбирается случайным образом
- выполняем цикл, пока одна из армий не опустеет
- делаем ход игрока, и удаляем вражеский юнит, если нужно
- делаем ход компьютера, и удаляем вражеский юнит, если нужно

#### SuitableForAttackUnitsFinderImpl
Класс для поиска юнитов, подходящих для атаки

Содержит метод `List getSuitableUnits(List> unitsByRow, boolean isLeftArmyTarget)`, который определяет список юнитов,
подходящих для атаки, для атакующего юнита одной из армий.
Цель метода — исключить ненужные попытки найти кратчайший путь между юнитами,
которые не могут атаковать друг друга.
Сложность: O(n*m) - (n - количество колонок, m - количество юнитов в колонке)
- делаю обход колонок в цикле, в зависимости от того с какой стороны армия, это будет прямой или обратный обход
- при обходе запоминаю юниты колонки в массив, при следующей итерации использую сохраненные данные,
  чтоб понять есть ли юнит перед текущим в этой же строке

Все очень просто: цикл идет от внешней шеренги юнитов и записывает положения юнитов в массив. Массив даже чистить не
надо, так как если перед юнитом кто-то стоит, то атаковать его нельзя (там же всего три колонки, вариант того что юнит
может бродить между шеренгами в поиске пути к врагу я думаю рассматривать не стоит)

#### UnitTargetPathFinderImpl
Класс поиска пути между юнитами

Содержит метод `List getTargetPath(Unit attackUnit, Unit targetUnit, List existingUnitList)`, который определяет
кратчайший маршрут между атакующим и атакуемым юнитом и возвращает его в виде списка узлов
содержащих координаты каждой точки данного кратчайшего пути. На каждом узле храню расстояние, количество узлов
не может быть больше числа клеток на поле. Каждый
Сложность: `~O(n * m * log(n * m))`. (n - ширина, m - высота поля)
- использую цикл, количество итераций не может превышать количество клеток игрового поля `(n * m)`
- для каждой клетки добавляется значение дистанции в приоритетную очередь, тут сложность логарифмическая `~O(log(N))`,
  N - число элементов в очереди, а число это не может быть больше количества клеток на поле: n * m (n - ширина, m - высота поля)
- для каждой клетки также проверяю соседей - это константная сложность O(4) - может и меньше,
  клетка может не иметь некоторых соседей, если она на краю поля.
- продолжаю цикл пока не найду целевой юнит или пока не закончатся пути,
  для контроля храню все расстояния от атакующего юнита до всех пройденных точек в двумерном массиве
  `@code distance = new int[WIDTH][HEIGHT]`, каждый элемент хранит количество шагов от атакующего юнита до себя
  и не может быть перезаписан большим значением, то есть хранится именно минимально количество шагов.
  Таким образом бесконечные циклы исключены